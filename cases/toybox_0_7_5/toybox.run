#!/usr/bin/env python2.7

"""
"""
import argparse
import os.path
import subprocess as sp
import hashlib
import json

CLEANUP = False

#infer
#bug_hashes = ["9e552ffde24e092a68a9402f43fcf020","01c76e0bb9d35d939d43a1028a9dd9ac","696aeec43c6284e8bd25869ad9d0cf51","8c55545e7e82f061034ad6d4b6140410","f632dfa9f5e23910b89e4f6e8278dd37","8e1f1948781a4f34a44359b50a3fc061","f3234bcffd1116814edd65b5fc58651a","55cc05beebe9c456a02bbaa105971729","fff5278e0ad9b62e11f0c31292f3cf1b","04d6a427df96cff687b61e9a0e1a6bea","f6b2a11f76075c6296d03cc4222e2259"]

#cppcheck
#bug_hashes = []

#clang
bug_hashes = ["62bfea16602609b9b604f105dd8806ac","b2d2a68c9c476c68eaf8cbe8ae78e818","996b3375d3980946fb41243a4234c44d","cee49f61b5ecd1f2da90f0baaf635fdd","0b784dc1a7078a89f68d2ed454929810","2e0b9310d7807bfad1a576cee5522eba","4261c2084283bb88226766cc65daa143","eca29724fde9812c89ef80042e199ecf","b0a4dc55b0b241acb3878c4fcd67ddd6","cf7d98b52c49298868002dc01e2d5159","3c9de11f3d294ab390e4361206119dfc","05332104e98f1d29b2733da0fc02e18d","3a85ed54be8b9aa11d76ab871c7a554f","09a1f0f59b8349d7add683f4875eaf98","f0ec20e6526351581f54f79991d8b771","fa7e7a0ad248ab901734ef81a383b134","168104a3064dfad654f1e10318c4afa3","bb7bbc3774fd0a4b3279f2a362c35a5b","36cc6b899deb003264e1e6d4c53924e6","ee60f6c19fa3a6d3ce0f6d62c12c3848","3eb113f83a2dc9cdd058db85b922229f","ffafee65008bfba9883938a53e581dce","17624f4db57cf891523697df858b7dc3","4d39f6a6d904669b8c38406ebaf00acb","c53aa7bf06a8ea16dc990d1175ee4c37","f9085c2100f44c20d14525d66fde6200","8366016a5d1acf6dec334cc1d5a3ba91"]


def vcmd(cmd, inp=None, shell=True):
    proc = sp.Popen(cmd,shell=shell,stdin=sp.PIPE,stdout=sp.PIPE,stderr=sp.PIPE)
    rs =  proc.communicate(input=inp)
    exit_code = proc.wait()
    return rs, exit_code

def runcmd(cmd):
    try:
        #print '$', cmd
        (_,rs_err), exit_code = vcmd(cmd)
        #assert not rs_err, rs_err
        #print 'ecode', exit_code
        return exit_code
    except:
        #print("cmd '{}' failed".format(cmd))
        return -1

def phash(v):
    import sys
    return hash(v) % ((sys.maxsize + 1) * 2)
    
def printHashCodes(jsonFile, outFile, filter=True):
    jsonFile = open(jsonFile, 'r')
    values = json.load(jsonFile)
    jsonFile.close()

    hashCodesStr = [bug['hash'] for bug in values]
    nonReachedList=[]
    if filter:
        hashCodesStr = [hsh for hsh in hashCodesStr if hsh in bug_hashes]
        nonReachedList = ['-'+hsh for hsh in bug_hashes if hsh not in hashCodesStr]

    f = open(outFile, "a")
    f.write('\n'.join(hashCodesStr))
    f.write('\n')
    f.write('\n'.join(nonReachedList))
    f.close()

def similar(tdir, f1, f2):
    tf1 = "{}/f1.txt".format(tdir)
    tf2 = "{}/f2.txt".format(tdir)

    assert runcmd("rm -rf {} {}".format(tf1, tf2)) == 0

    cleansort = lambda f, tf: "cat {} | sort | egrep \"^(CONFIG_|# CONFIG_.*is not set)\" > {}".format(f, tf)
    assert runcmd(cleansort(f1, tf1))  == 0
    assert runcmd(cleansort(f2, tf2))  == 0
    return runcmd("diff {} {}".format(tf1, tf2)) == 0
    
                 
if __name__ == "__main__":
    #note:  use abspath (considers symlinks) instead of realpath (ignore symlinks)
    me_file = os.path.abspath(os.path.expanduser(__file__))  
    me_dir = os.path.dirname(me_file)

    parser = argparse.ArgumentParser()
    parser.add_argument("inputs", help="input configurations")
    args = parser.parse_args()
    inp = args.inputs.strip() #"x 0, y 1, z 0"

    import time
    tid = "{}.{}".format(time.time(), phash(inp))


    HOME_DIR="/home/vagrant"
    KCONFIG_DIR="{}/kconfig_case_studies".format(HOME_DIR)

    saToolVersion="7"
    saTool='clang{}'.format(saToolVersion) #cppcheck infer clang
    progName="toybox_0_7_5"
    tarFile = "toybox-0.7.5.tar.gz"
    exratedFile = "toybox-0.7.5"

    driver="{}/scripts/driver_variants/driver_{}.sh".format(KCONFIG_DIR, saTool)
    deduplicateBugs='python2.7 {}/bugs/scripts/deduplicate_bugs.py'.format(KCONFIG_DIR)
    
    BENCH_DIR="{}/cases/{}".format(KCONFIG_DIR, progName)
    SRC_DIR= "{}/{}".format(BENCH_DIR, progName, tid)
    OUTPUT_DIR= "{}/output4igen".format(BENCH_DIR)
    RESULT_DIR = "{}/varbugs/output/{}/{}_results".format(HOME_DIR, progName, saTool)
    jsonFile="{}/unique.json.results".format(RESULT_DIR)

    defConfigFile="{}/def.config".format(BENCH_DIR)
    configFile="{}/build/configs/{}.config".format(BENCH_DIR, tid)
    
    assert not os.path.isdir(SRC_DIR), SRC_DIR

    cmd="cd {} && tar -xf {}".format(BENCH_DIR, tarFile)
    assert runcmd(cmd) == 0

    cmd="cd {} && mv {} {}".format(BENCH_DIR, exratedFile, SRC_DIR)
    assert runcmd(cmd) == 0

    cmd="cp {} {}".format(defConfigFile, configFile)
    assert runcmd(cmd) == 0

    parts =  [p.split() for p in inp.split(" , ")]
    ys, ns = [], []
    neithers = {}
    for name, val in parts:
        if val == 'y':
            ys.append(name)
        elif val == 'n':
            ns.append(name)
        else:
            neithers[name] = val

    setcmd = lambda name: \
             "sed -e 's/.*{} .*/{}=y/' -i {}".format(name, name, configFile)

    unsetcmd = lambda name:\
               "sed -e 's/.*{}=y.*/# {} is not set/' -i {}".format(
                   name, name, configFile)
    
    setNonBool = lambda name, value: \
            "sed -e 's/.*{}.*/{}={}/' -i {}".format(name, name, value, configFile)

    for name in ys:
        runcmd(setcmd(name))
        
    for name in ns:
        runcmd(unsetcmd(name))
        
    for name, value in neithers.iteritems():
        runcmd(setNonBool(name, value))
    
    #runtest
    logFile = "{}/{}_{}_build.log".format(OUTPUT_DIR, progName, tid)
    outF = open(logFile, "w+")
    outF.write("---Configuration:{}, stime+hash:{}\n".format(inp, tid))    
    outF.close()
    runDriver = lambda : runcmd("cd {} && {} build {} build/configs >> {} 2>&1".format(SRC_DIR, driver, progName, logFile))
    runBugProcessor = lambda : runcmd("cd {} && {} {} >> {} 2>&1".format(RESULT_DIR, deduplicateBugs, saTool, logFile))

    found = True
    if runDriver() != 0:
        found = False

    if found and runBugProcessor() != 0:
        found = False
    
    resultFile = "{}/{}_{}_interesting.txt".format(OUTPUT_DIR, progName, tid)
    if found:
        printHashCodes(jsonFile, resultFile)
    else:
        runcmd("touch {}".format(resultFile))

    if CLEANUP:
        assert runcmd("rm -rf {}".format(SRC_DIR)) == 0
        assert runcmd("rm -rf {}/*".format(RESULT_DIR)) == 0
        assert runcmd("rm -rf {}/build/configs/*".format(BENCH_DIR)) == 0

    print resultFile